1. 何为比较排序? 比较排序的最好和最差增长量级是什么? 对于任意排序算法来说, 最好和最差的增长量级是什么?
* 一般将基于比较进行的排序称为比较排序。包括:
    * 插入排序
    * 归并排序
    * 堆排序
    * 快速排序
    * 选择排序
    * 冒泡排序
    * 希尔排序
    从理论上来讲, 排序一个无序列表最快速度是O(nlog(n)), 最慢无上限

2.冒泡排序的增长量级是多少? 为什么奥巴马会认为它是错误的排序方式?
* O(n^2)属于比较慢的排序方式之一

3.基数排序的增长量级是什么? 使用它的前提条件是什么?
* O(nlogx(n))其中x是桶的个数. 前提是基数固定

4.何为稳定排序, 它在实际使用中为何很重要.
* 稳定排序即增长量级不会随着输入的变化而变化, 最好情况和最快的情况增长量级是一样的.

5.最差的排序算法是什么(名字)?
* Bogo排序(Bogo-sort)，又被称为猴子排序，是一种恶搞排序算法，其算法就是坑爹的将元素随机打乱，然后紧紧检查其是否符合排列顺序，
若否，则继续进行随机打乱，继续检查结果，直到符合排列顺序。Bogo排序的最坏时间复杂度为 O(∞)，一辈子也不能输出排序结果，平均时间复杂度为O(n·n!)。
然而，有个看似笑话的方法声称可以用O(n)实现Bogo排序，依照量子理论的平行宇宙解释，使用量子随机性随机地重新排列元素，
不同的可能性将在不同的宇宙中展开，总有一种可能猴子得到了正确的顺序，量子计算机找到了这个宇宙后，就开始毁灭其他排序不成功的宇宙，
剩下一个观察者可以看到的正确顺序的宇宙。如果想要迈出这个看似荒诞，但令人无比兴奋的"高效算法"的第一步，请先证明"平行宇宙解释"的正确性。

6.C语言库用的什么排序方法, python用的什么排序方法? 这些方法是稳定的吗?
* C语言中的std::sort方法使用的排序方式是内省排序
* 内省排序的实现过程是这样的，首先由快速排序开始，当递归深度超过一定程度时，转换为堆排序。所以内省排序既能在常规数据集上实现快速排序的高性能，
又能在最坏情况下仍保持 O（N log N） 的时间复杂度。
* python内置算法是TimSort: TimSort是一个归并排序做了大量优化的版本。对归并排序排在已经反向排好序的输入时表现O(n^2)的特点做了特别优化。
对已经正向排好序的输入减少回溯。对两种情况混合（一会升序，一会降序）的输入处理比较好。是一个稳定排序方法.